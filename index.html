<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VC Investment Network Visualization</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
        body, html { height: 100%; margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #searchContainer { position: absolute; z-index: 10; top: 20px; left: 50%; transform: translateX(-50%); }
        #searchBox { width: 300px; padding: 10px; font-size: 16px; }
        .link { stroke: #bbb; stroke-opacity: 0.6; stroke-width: 1px; }
        .node circle { stroke: #fff; stroke-width: 1.5px; }
        .node text { font-size: 10px; fill: #333; pointer-events: none; text-anchor: middle; transform: translateY(15px); }
        svg { cursor: grab; }
        #backButton {
            position: absolute;
            top: 20px;
            right: 20px; /* Or left, depending on where you want the button */
            z-index: 10;
            padding: 10px;
            font-size: 16px;
            display: none; /* It will be shown programmatically */
        }
    </style>
</head>
<body>
    <div id="searchContainer">
        <input id="searchBox" list="vcList" placeholder="Type VC Fund Name...">
        <datalist id="vcList"></datalist>
        <button onclick="searchAndDisplay()">Search</button>
    </div>
    <button id="backButton" onclick="location.reload()">Back</button>
    <svg></svg>
    <script>
        let graphData;
        const svg = d3.select("svg").attr("width", "100%").attr("height", "100%");
        svg.call(d3.zoom().on("zoom", (event) => g.attr("transform", event.transform)));
        const g = svg.append("g");
        let width = window.innerWidth;
        let height = window.innerHeight;
        d3.json("vc_investments_graph.json").then(data => { graphData = data; setupVCNamesList(graphData.nodes); });
        svg.call(d3.zoom().on("zoom", (event) => { g.attr("transform", event.transform); }));
        const colorScale = d3.scaleThreshold().domain([1, 2, 6, 10]).range(["blue", "green", "orange", "black"]);
        function showSearch() {
            document.getElementById('searchContainer').style.display = 'block';
            document.getElementById('backButton').style.display = 'none';
            g.selectAll("*").remove(); // Clear SVG
            document.getElementById('backButton').style.display = 'block';
            document.getElementById('searchBox').value = ''; // Reset search box
            // Repopulate dropdown if needed
            setupVCNamesList(graphData.nodes);
        }

        document.getElementById('backButton').addEventListener('click', showSearch);

        function setupVCNamesList(nodes) { const vcList = document.getElementById("vcList"); nodes.forEach(node => { let option = document.createElement("option"); option.value = node.id; vcList.appendChild(option); }); }
        function searchAndDisplay() {
            const searchValue = document.getElementById("searchBox").value;
            const filteredData = filterDataForVC(searchValue);
            if (filteredData.nodes.length > 0) {
                document.getElementById("searchContainer").style.display = "none";
                document.getElementById('backButton').style.display = 'block'; // Show the back button
                updateGraph(filteredData, searchValue);
            } else {
                alert("No VC fund found with the name \"" + searchValue + "\".");
            }
        }
        function filterDataForVC(vcName) { const nodes = new Map(); const links = []; graphData.links.forEach(link => { if (link.source === vcName || link.target === vcName) { links.push(link); nodes.set(link.source, graphData.nodes.find(n => n.id === link.source)); nodes.set(link.target, graphData.nodes.find(n => n.id === link.target)); } }); return { nodes: Array.from(nodes.values()), links }; }
        function updateGraph({ nodes, links }, selectedVC) {
            g.selectAll("*").remove();

            // Calculate co-investment counts
            let coInvestmentCounts = {};
            links.forEach(link => {
                let source = typeof link.source === "object" ? link.source.id : link.source;
                let target = typeof link.target === "object" ? link.target.id : link.target;
                if (source === selectedVC || target === selectedVC) {
                    if (source !== selectedVC) {
                        coInvestmentCounts[source] = (coInvestmentCounts[source] || 0) + link.value;
                    }
                    if (target !== selectedVC) {
                        coInvestmentCounts[target] = (coInvestmentCounts[target] || 0) + link.value;
                    }
                }
            });

            nodes.forEach(node => {
                node.coInvestments = node.id === selectedVC ? null : coInvestmentCounts[node.id] || 0;
            });

            // Set the center for the selected VC
            const centerX = width / 2;
            const centerY = height / 2;
            const selectedNode = nodes.find(node => node.id === selectedVC);
            selectedNode.fx = centerX;
            selectedNode.fy = centerY;

            // Sort nodes by co-investment count and distribute them in circles
            let sortedNodes = nodes.filter(n => n.id !== selectedVC)
                                   .sort((a, b) => b.coInvestments - a.coInvestments);

            let circleData = [];
            let currentNodesPerCircle = 8;
            let currentRadius = 100;

            while (sortedNodes.length > 0) {
                let nodesInThisCircle = sortedNodes.splice(0, currentNodesPerCircle);
                let angleStep = (Math.PI * 2) / nodesInThisCircle.length;

                nodesInThisCircle.forEach((node, index) => {
                    node.theta = angleStep * index;
                    node.radius = currentRadius;
                    node.x = centerX + node.radius * Math.cos(node.theta);
                    node.y = centerY + node.radius * Math.sin(node.theta);
                });

                circleData.push(...nodesInThisCircle);
                currentNodesPerCircle += 2;
                currentRadius += 150;
            }

            // Create the simulation
            const simulation = d3.forceSimulation(nodes)
                                    .force("charge", d3.forceManyBody().strength(-120)) // Increase repulsion
                                    .force("collide", d3.forceCollide().radius(20)) // Increase radius to avoid overlap and add space
                                    .force("center", d3.forceCenter(width / 2, height / 2)) // Keep the graph centered
                                    .force("link", d3.forceLink(links).id(d => d.id).distance(100)) // Adjust link distance for spacing
                                    .on("tick", ticked);

            const nodes = g.selectAll(".node")
                            .data(graphData.nodes)
                            .enter().append("g")
                            .attr("class", "node");
                
            nodes.append("circle")
                .attr("r", 5)
                .style("fill", d => colorScale(d.group));
            
            nodes.append("text")
                .text(d => d.id)
                .attr("font-size", "10px")
                .attr("text-anchor", "middle")
                .attr("dy", "-1em"); // Position the text above the circle
            
            // Example setup for links
            const links = g.selectAll(".link")
                .data(graphData.links)
                .enter().append("line")
                .attr("class", "link")
                .style("stroke-width", d => Math.sqrt(d.value));


            for (let i = 0; i < 300; i++) simulation.tick();

            // Draw nodes
            const nodeElements = g.selectAll(".node")
                .data(nodes)
                .enter()
                .append("circle")
                .attr("r", 5)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .style("fill", d => d.id === selectedVC ? "yellow" : "red");

            const labelElements = g.selectAll(".label")
                                    .data(nodes)
                                    .enter()
                                    .append("text")
                                    .attr("x", d => d.x)
                                    .attr("y", function(d) {
                                        // Adjusted vertical offset logic
                                        let baseOffset = 20; // Starting offset from node center
                                        let additionalOffset = d.id.length > 15 ? 5 : 0; // Additional offset for longer labels
                                        return d.y + baseOffset + additionalOffset;
                                    })
                                    .text(d => `${d.id}${d.coInvestments ? ` (${d.coInvestments})` : ''}`)
                                    .attr("font-size", "12px")
                                    .style("text-anchor", "middle")
                                    .each(function(d) {
                                        // Basic overlap check (simplified and for illustration purposes)
                                        let bbox = this.getBBox();
                                        let aboveNode = { x: d.x, y: d.y - bbox.height };
                                        if (aboveNode.y < 0) { // If label goes beyond the top boundary
                                            d3.select(this).attr("y", d.y + bbox.height + 5); // Move label below the node
                                        }
                                    });

            
            nodeElements.on('click', function(event, d) {
                // Ensure we don't trigger updates for the already-selected node
                if (d.id !== selectedVC) {
                    // It's important to actually update the nodes' fixed positions before re-calling updateGraph
                    nodes.forEach(n => {
                        n.fx = null;
                        n.fy = null;
                    });
                    updateGraph({ nodes, links }, d.id); // Call updateGraph with the new selected node
                }
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                if (d.id !== selectedVC) {
                    d.fx = null;
                    d.fy = null;
                }
            }

            nodeElements.call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));
        }
    </script>
</body>
</html>
